/**
 * AnkiConnect Client for bi-directional synchronization
 * Allows VoiceCards to sync progress with Anki desktop
 *
 * Requires AnkiConnect add-on installed in Anki:
 * https://ankiweb.net/shared/info/2055492159
 */

import axios from 'axios';
import { Card, CardReview, Deck } from '../types/index.js';

// AnkiConnect configuration
const ANKI_CONNECT_URL = 'http://localhost:8765';
const ANKI_CONNECT_VERSION = 6;

// AnkiConnect types
interface AnkiCard {
  noteId: number;
  cardId: number;
  deckName: string;
  modelName: string;
  fields: Record<string, string>;
  tags: string[];
  type: number;
  queue: number;
  due: number;
  interval: number;
  factor: number;  // Ease factor * 1000
  reviews: number;
  lapses: number;
  left: number;
  mod: number;  // Modification timestamp
}

interface AnkiNote {
  noteId: number;
  modelName: string;
  fields: Record<string, string>;
  tags: string[];
}

interface AnkiDeck {
  name: string;
  desc: string;
  cardCount: number;
  newCount: number;
  learningCount: number;
  reviewCount: number;
}

export class AnkiConnectClient {
  private apiUrl: string;
  private version: number;

  constructor(url: string = ANKI_CONNECT_URL, version: number = ANKI_CONNECT_VERSION) {
    this.apiUrl = url;
    this.version = version;
  }

  /**
   * Make a request to AnkiConnect
   */
  private async invoke(action: string, params: any = {}): Promise<any> {
    try {
      const response = await axios.post(this.apiUrl, {
        action,
        version: this.version,
        params
      });

      if (response.data.error) {
        throw new Error(`AnkiConnect error: ${response.data.error}`);
      }

      return response.data.result;
    } catch (error: any) {
      if (error.code === 'ECONNREFUSED') {
        throw new Error('Anki is not running or AnkiConnect is not installed');
      }
      throw error;
    }
  }

  /**
   * Check if Anki is running and AnkiConnect is available
   */
  async checkConnection(): Promise<boolean> {
    try {
      const result = await this.invoke('version');
      return result === this.version;
    } catch {
      return false;
    }
  }

  /**
   * Request permission for actions (required for some operations)
   */
  async requestPermission(): Promise<void> {
    await this.invoke('requestPermission');
  }

  /**
   * Get all deck names from Anki
   */
  async getDecks(): Promise<string[]> {
    return await this.invoke('deckNames');
  }

  /**
   * Get detailed deck statistics
   */
  async getDeckStats(deckName: string): Promise<AnkiDeck> {
    const stats = await this.invoke('getDeckStats', { decks: [deckName] });
    return stats[deckName];
  }

  /**
   * Get all cards from a specific deck
   */
  async getCardsFromDeck(deckName: string): Promise<AnkiCard[]> {
    // Find all cards in the deck
    const cardIds = await this.invoke('findCards', {
      query: `deck:"${deckName}"`
    });

    if (!cardIds || cardIds.length === 0) {
      return [];
    }

    // Get card info for all cards
    const cardsInfo = await this.invoke('cardsInfo', {
      cards: cardIds
    });

    return cardsInfo;
  }

  /**
   * Get cards due for review
   */
  async getDueCards(deckName?: string): Promise<AnkiCard[]> {
    const query = deckName
      ? `deck:"${deckName}" is:due`
      : 'is:due';

    const cardIds = await this.invoke('findCards', { query });

    if (!cardIds || cardIds.length === 0) {
      return [];
    }

    return await this.invoke('cardsInfo', { cards: cardIds });
  }

  /**
   * Import a deck from Anki to VoiceCards
   */
  async importDeck(deckName: string): Promise<{
    deck: Deck,
    cards: Card[],
    reviews: CardReview[]
  }> {
    // Get all cards from the deck
    const ankiCards = await this.getCardsFromDeck(deckName);

    // Get deck info
    const deckStats = await this.getDeckStats(deckName);

    // Convert to VoiceCards format
    const deck: Deck = {
      id: '', // Will be generated by database
      user_id: '', // Will be set by caller
      name: deckName,
      description: deckStats.desc || `Imported from Anki: ${ankiCards.length} cards`,
      tags: ['anki-import'],
      is_public: false,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    const cards: Card[] = [];
    const reviews: CardReview[] = [];

    for (const ankiCard of ankiCards) {
      // Get note info for field content
      const noteInfo = await this.invoke('notesInfo', {
        notes: [ankiCard.noteId]
      });
      const note = noteInfo[0];

      // Create VoiceCards card
      const card: Card = {
        id: '', // Will be generated
        deck_id: '', // Will be set after deck creation
        front: note.fields['Front']?.value || '',
        back: note.fields['Back']?.value || '',
        hint: note.fields['Hint']?.value || '',
        tags: note.tags,
        card_order: cards.length,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      // Extract image/audio URLs if present
      if (note.fields['Front']?.value.includes('<img')) {
        const imgMatch = note.fields['Front'].value.match(/src="([^"]+)"/);
        if (imgMatch) {
          card.image_url = imgMatch[1];
        }
      }

      cards.push(card);

      // Create review record with Anki's SRS data
      if (ankiCard.reviews > 0) {
        const review: CardReview = {
          id: '', // Will be generated
          card_id: '', // Will be set after card creation
          user_id: '', // Will be set by caller
          ease_factor: ankiCard.factor / 1000, // Convert from Anki's format
          interval: ankiCard.interval,
          repetitions: ankiCard.reviews,
          quality: 3, // Default to "good"
          review_time: undefined,
          session_id: undefined,
          last_reviewed_at: new Date(ankiCard.mod * 1000).toISOString(), // Convert from Unix timestamp
          next_review_at: this.calculateNextReviewDate(ankiCard.due, ankiCard.queue),
          created_at: new Date().toISOString()
        };

        reviews.push(review);
      }
    }

    return { deck, cards, reviews };
  }

  /**
   * Export VoiceCards progress back to Anki
   */
  async exportProgress(
    cardMappings: Array<{ voiceCardId: string, ankiCardId: number }>,
    reviews: CardReview[]
  ): Promise<void> {
    for (const review of reviews) {
      const mapping = cardMappings.find(m => m.voiceCardId === review.card_id);
      if (!mapping) continue;

      // Update card scheduling in Anki
      await this.invoke('setEaseFacto', {
        cards: [mapping.ankiCardId],
        ease: Math.round(review.ease_factor * 1000) // Convert to Anki format
      });

      // Answer card to update interval
      // Quality mapping: 0=again, 2=hard, 3=good, 5=easy
      let ankiEase = 3; // Default to good
      if (review.quality === 0) ankiEase = 1; // Again
      else if (review.quality === 2) ankiEase = 2; // Hard
      else if (review.quality === 3) ankiEase = 3; // Good
      else if (review.quality === 5) ankiEase = 4; // Easy

      // Schedule the card
      await this.invoke('answerCards', {
        answers: [{
          cardId: mapping.ankiCardId,
          ease: ankiEase
        }]
      });
    }
  }

  /**
   * Sync all progress between VoiceCards and Anki
   */
  async syncProgress(
    deckName: string,
    voiceCardsReviews: CardReview[],
    ankiCardMappings: Array<{ voiceCardId: string, ankiCardId: number }>
  ): Promise<{
    imported: number,
    exported: number,
    conflicts: Array<{ cardId: string, reason: string }>
  }> {
    let imported = 0;
    let exported = 0;
    const conflicts: Array<{ cardId: string, reason: string }> = [];

    // Get current Anki state
    const ankiCards = await this.getCardsFromDeck(deckName);

    // Create a map for quick lookup
    const ankiCardMap = new Map<number, AnkiCard>();
    ankiCards.forEach(card => ankiCardMap.set(card.cardId, card));

    // Process each VoiceCards review
    for (const review of voiceCardsReviews) {
      const mapping = ankiCardMappings.find(m => m.voiceCardId === review.card_id);
      if (!mapping) continue;

      const ankiCard = ankiCardMap.get(mapping.ankiCardId);
      if (!ankiCard) continue;

      // Compare modification times to determine which is newer
      const voiceModTime = new Date(review.created_at).getTime();
      const ankiModTime = ankiCard.mod * 1000; // Convert from Unix timestamp

      if (voiceModTime > ankiModTime) {
        // VoiceCards is newer - export to Anki
        try {
          await this.exportProgress([mapping], [review]);
          exported++;
        } catch (error: any) {
          conflicts.push({
            cardId: review.card_id,
            reason: `Failed to export: ${error.message}`
          });
        }
      } else if (ankiModTime > voiceModTime) {
        // Anki is newer - import to VoiceCards
        // This would update the VoiceCards database
        imported++;
      } else {
        // Same modification time - no action needed
      }
    }

    return { imported, exported, conflicts };
  }

  /**
   * Create a new deck in Anki
   */
  async createDeck(deckName: string): Promise<void> {
    await this.invoke('createDeck', { deck: deckName });
  }

  /**
   * Add a new card to Anki
   */
  async addCard(
    deckName: string,
    front: string,
    back: string,
    tags: string[] = []
  ): Promise<number> {
    return await this.invoke('addNote', {
      note: {
        deckName,
        modelName: 'Basic',
        fields: {
          Front: front,
          Back: back
        },
        tags
      }
    });
  }

  /**
   * Calculate next review date from Anki's due value
   */
  private calculateNextReviewDate(due: number, queue: number): string {
    const now = new Date();

    if (queue === 0 || queue === 1) {
      // New or learning card - due is in minutes
      now.setMinutes(now.getMinutes() + due);
    } else if (queue === 2) {
      // Review card - due is days since collection creation
      // This is approximate - Anki uses collection creation date
      now.setDate(now.getDate() + due);
    }

    return now.toISOString();
  }

  /**
   * Monitor Anki for real-time changes
   */
  async *monitorChanges(
    deckName: string,
    intervalMs: number = 5000
  ): AsyncGenerator<{ type: 'review' | 'new_card', data: any }> {
    let lastState = await this.getCardsFromDeck(deckName);

    while (true) {
      await new Promise(resolve => setTimeout(resolve, intervalMs));

      const currentState = await this.getCardsFromDeck(deckName);

      // Detect changes
      for (const card of currentState) {
        const oldCard = lastState.find(c => c.cardId === card.cardId);

        if (!oldCard) {
          // New card added
          yield { type: 'new_card', data: card };
        } else if (card.mod > oldCard.mod) {
          // Card was reviewed
          yield { type: 'review', data: card };
        }
      }

      lastState = currentState;
    }
  }
}